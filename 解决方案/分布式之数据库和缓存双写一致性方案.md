## 方案

### 1、先更新数据库，再更新缓存

这套方案，是普遍反对的

#### 原因一，线程安全角度

（1）线程A更新数据库

（2）线程B更新数据库

（3）线程B更新缓存

（4）线程A更新缓存

正常情况先线程A的数据先与线程B更新缓存，但是因为网络等原因导致线程B比线程A先更新缓存，导致了脏数据，因此这种方案一般不考虑



#### 原因二，业务场景角度

（1）写多读少，采用这种方案导致，数据没有读到就频繁的更新，浪费性能

接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。

### 2、先删缓存，再更新数据库

**方案会导致数据不一致**

（1）请求A进行写操作，删除缓存

（2）请求B查询发现缓存不存在

（3）请求B去数据库查询得到旧值

（4）请求B将旧值写入缓存

（5）请求A将新值写入数据库（写入时加了行锁）



#### **解决方案**

延时双删策略

```java
public void write(String key, Object data) {
	redise.del(key);
	db.update(data);
	Thread.sleep(1000);
	redis.del(key);
}
```



### 3、先更新数据库，再删缓存(推荐)

老外提出了一个缓存更新套路，名为《Cache-Aside pattern》。其中就指出：

- **失效**：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中；
- **命中**：应用程序从cache中取数据，取到后返回；
- **更新**：先把数据存到数据库中，成功后，再让缓存失效；



**依然存在并发问题**

同时有两个请求，A做查询B做更新

1、缓存刚好失效

2、A查询到数据库，得到旧值

3、B更新数据库

4、B更新缓存

5、A将旧值更新到缓存



A请求查询到数据库的值更新缓存之间 B请求更新了数据库并且更新了缓存，最后A请求更新缓存覆盖了B请求的最新值，导致脏数据

A  R(db) -> B U(db) -> B redis ->  A redis

实际上出现这种情况的概率很小，数据库查询速度 远高于 写速度
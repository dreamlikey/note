redis 数据超过 过期时间 或 内存打满时都需要从内存中淘汰这些数据，实际上在进行数据淘汰时

https://developer.aliyun.com/article/257459



## 过期数据清理策略



### 过期数据清理时机

redis只在空闲时清理过期key

1、访问key时会判断key是否过期，逐出过期key

2、CPU空闲时在定期serverCron任务中，逐出部分过期key

3、每次事件循环执行的时候，逐出部分过期key



### 清理算法

Redis过期key清理机制对清理的频率 和 时间都有限制，在尽量不影响服务的情况下进行过期key的清理，以达到长时间服务的性能最优。

Redis会**周期性的随机测试**一批设置了过期时间的key并进行处理，对过期的key进行清理。具体算法如下

1、Redis配置项hz定义了serverCron任务的执行周期，默认为10，即CPU空闲时每秒执行10次

2、每次过期key的清理不超过CPU时间的25%，hz为1，则一次清理的最大时间不超过250ms，hz=10一次清理的最大时间为25ms

3、清理时依次遍历所有db

4、从一个库中随机选择20key，判断是否过期，若过期则清理

5、若有5个以上key过期，则重复步骤4，否则遍历下一个db

最佳实践

6、清理过程中若超过了最大时间则立即退出清理



1、这是基于概率的简单算法，假设抽样的数据能代表整个key空间，redis持续清理过期的数据直至将过期key比率降低到25%一下。这样意味着长期来看一直**有1/4已过期的数据滞留在内存中，因为采用随机取key判断是否过期进行清理，所以是不可能清理完所有过期key**

2、调高HZ参数可以提升清理频率，但是会增加CPU消耗，更加密集频繁的进行清理



### 数据逐出算法（内存淘汰算法）

redis会自动清理过期key，但内存还是达到最大内存，此时就进行内存淘汰（数据逐出），直到内存小于最大内存时。



可选的内存淘汰策略（逐出策略）如下：

volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选出最近最少使用的数据淘汰

volatile-ttl：从已设置过期时间的数据及（）中挑出即将过期的数据 淘汰

volatile-random：从已设置过期时间的数据中 任意挑选数据淘汰

allkeys-lru：从数据集中挑选最近最少使用的数据 淘汰

allkeys-random：从数据集中任意（随机）挑选数据 淘汰

no-envication：禁止驱逐数据







### 最佳实践

1、尽量将不同业务的key分散在不同的db上

Redis的过期Key清理策略和强制淘汰策略都会遍历各个db。将key分布在不同的db有助于过期Key的及时清理。另外不同业务使用不同db也有助于问题排查和无用数据的及时下线



某一业务相对其他业务设置了更多的过期key，若将此业务分配到某一单独的库，清理的过期key更多清理率更高
#### 回顾

并发编程的三大问题：可见性、原子性、有序性

CPU缓存不能及时刷新到内存带来可见性问题（多CPU）

线程切换带来原子性问题（同一个CPU）

编译器为了优化性能而改变程序中语句的先后顺序导致有序性问题



而“缓存不能及时刷新“和“编译器为了优化性能而改变程序中语句的先后顺序”都是重排序的一种



#### 重排序概念

**在执行程序时为了提高性能，编译器和处理器(CPU)往往会对指令做重排序**

从java源码到最终实际执行的指令序列，会分别经历下面三种重排序：

源代码--》编译器优化的重排序--》指令级并行的重排序--》内存系统的重排序--》最终指令

1. 编译器优化重排序

   在不改变单线程程序语意的情况下，编译器可以重新安排语句的执行顺序

2. 指令级并行重排序

   处理器将多条指令重叠执行。如果不存在数据依赖，处理器可以改变程序指令的执行顺序。

3. 内存系统重排序

   处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去可能是在乱序执行。

#### 重排序规则

##### 重排序准守数据依赖性

如果两个操作访问的同一个变量，且其中一个是写操作，此时这两个操作之间存在数据依赖性。

存在数据依赖性的三种情况：

① 写后读：a = 1;b = a; 写一个变量之后，再读这个位置。
② 写后写：a = 1;a = 2; 写一个变量之后，再写这个变量。
③ 读后写：a = b;b = 1;读一个变量之后，再写这个变量。

​	**存在数据依赖性的两个操作不可以重排序，数据依赖性只针对单个处理器中执行的程序指令和单个线程中执行的操作**

同一个线程中执行a=1;b=1; 不存在数据依赖性，可能重排序。

同一个线程中执行a=1;b=a; 存在数据依赖性，不可以重排序。



##### 重排序遵守as-if-serial 语义

as-if-serial语义：不管怎么重排序，单线程程序的执行结果不能改变。

A和B重排序之后，程序的执行结果不会改变，所以允许A、B重排序。A和C重排序之后，程序的执行结果会改变，所以不允许A、C重排序。

> 遵守数据依赖性和as-if-serial 语义实质上是一回事。为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。

#### 重排序带来的问题

重排序可以提高程序执行的性能，但程序执行顺序的改变，可能会导致多线程程序的**可见性问题**和**有序性问题**

举例

```java
初始状态：a = b = 0；x = y = 0；
Processor A：
	a = 1; // A1
	x = b; // A2
Processor B：
	b = 2; // B1
	y = a; // B2
```

如上代码，Processor A和Processor B同时执行，最终却可能得到x = y = 0的结果。



![img](https://mmbiz.qpic.cn/mmbiz_png/MepW0qEsgRCTjNp1quOWiahc7tf1eicxCfiaRwzib2189VT8gaYeBQc1I36ZdpV9mFiauQuhhbrYETs7ibEZ4xmVN41w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

第一步执行A1/B1将a=1写到缓冲区，此时写缓冲区还在等待其他写操作，不执行A3，所以内存中的a=0;

第二步执行A2/B2，处理器读取内存中的a，得到a=0;

虽然处理器 A 执行内存操作的顺序为：A1->A2，但内存操作实际发生的顺序却是：A2->A1。此时，**处理器 A 的内存操作顺序被重排序了**。



#### JMM如何解决重排序问题
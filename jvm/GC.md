### 垃圾回收算法

#### 复制算法

从根集合节点开始，标记出所有存活的对象，将存活的对象复制到一块新的内存区域，之后将原本那块内存全部回收掉

适用于新生代

#### 标记清除

标记清除分为：**标记和清除两个阶段**

通过根节点GC Root标记有从根节点开始的对象，没有

标记的对象就是未被引用的垃圾对象。然后在清除阶段清除所有未被标记的对象

##### 适用场景

存活对象觉多的情况效率高

适用于老年代



#### 标记整理





#### 分代收集



### 垃圾收集器

7种垃圾收集器，Serial、Serial Old、ParNew、Parallel Scavenge、Parallel Old、Cms、G1

Serial、ParNew、Parallel Scavenge 作用于新生代的垃圾收集器

Serial Old、Parallel Old、Cms  作用于老年代的垃圾收集器

G1 既可以进行新生代垃圾回收也可以进行老年代垃圾回收

**图中红X部分，JDK1.8之后不再支持**

![](image\GC_zrea.png)

#### 垃圾收集器分类

1. 串行垃圾回收器

   单线程的垃圾收集器， 垃圾收集线程工作时必须暂停其它所有用户线程Stop-the-World

   Serial

   Serial Old

2. 并行垃圾回收器

   垃圾回收线程并行的进行垃圾回收，垃圾回收线程工作时必须暂停所有用户线程造成Stop-the-World

   ParNew

   Parallel Scavenge

   Parallel  Old

3. 并发垃圾回收器

   CMS

4. G1垃圾回收器

   G1

#### Serial

串行垃圾收集器，使用复制算法，单线程的垃圾收集器， 垃圾收集线程工作时必须暂停其它所有用户线程Stop-the-World，适用于单一应用和单核服务器

#### Serial Old

串行老年代垃圾回收器与Serial垃圾收集器一样，不同的是它作用于老年代

#### ParNew

并行新生代垃圾回收器，使用**复制算法**，多个垃圾回收线程并行进行垃圾回收，比较Serial性能有所提高



#### Parallel Scavenge

并行新生代垃圾回收器，使用**复制算法**，俗称吞吐量优先收集器，可控制的吞吐量

吞吐量 = 运行用户代码时间/(运行用户代码时间+垃圾回收时间)，高吞吐量意味着高效利用CPU，

适用于后台计算而不需要太多交互的任务。

**自适应调节策略**也是Parallel Scavenge与ParNew的一个重要区别，虚拟机根据当前系统运行情况动态调节参数以提供最合适的停顿时间和最大吞吐量（-XX:MaxGCPauseMillis）

##### jvm参数

`-XX:+UseParallelGC` -`XX:+UseParallelOldGC`  启用Parallel Scavenge垃圾收集器，这两个参数可以互相激活



#### Parallel Old

Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“**标记-整理**”算法

#### CMS

并发标记清除垃圾收集器Concurrent Mark Sweep，作用于老年代， 基于**标记-清除**算法，垃圾回收线程和用户线程可同时工作

-XX:+UseConcMarkSweepGC

##### 4步过程

1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清除

##### 优点

并发收集，回收速度快、卡顿时间短

##### 缺点

**空间碎片**

​	空间碎片多，给对象分配带来麻烦，堆内存中找不到足够大的连续内存空间来分配对象

**无法回收浮动垃圾**

​	重新标记阶段，用户线程与垃圾回收线程并行执行，这个过程中用户线程产生新的垃圾对象（这就是浮动垃	圾），由于标记已经结束这部分新产生的垃圾没有被标记，所以当次垃圾回收不会回收掉这部分

**对CPU要求高**

​	

#### G1

G1不同于传统的垃圾收集器，使用了全新的垃圾回收算法，区块化垃圾回收



###### 特点
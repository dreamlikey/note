

oracle官方文档

https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html



1、确定什么样的对象是垃圾对象

2、该如何回收（垃圾回收算法）

3、具体的垃圾回收器回收

4、优劣势，该如何选型

5、垃圾回收调优



### **一、如何确定垃圾**

**什么是垃圾**

​	简单来说内存中不再被使用的空间就是垃圾

#### **如何定位垃圾**

​	1、引用计数法

​		无法解决的循环引用问题，已经没有虚拟机使用此算法

##### 	2、可达分析法

​		**a.  GCRoot**

​		把GC Root对象作为起点，来进行链路的扫描和访问，如果可达能访问到，就认为是活跃的不能回收，如果不可达不能访问，那就不可达可以回收，所有的GC Root扫描结束之后进行垃圾回收



​		**b.  可以成为GCRoot的对象**

​			1、虚拟机栈中引用的对象

​			2、方法区中静态类属性引用的对象（static修饰）

​			3、方法区中常量引用的对象（final修饰的对象）

​			4、本地方法栈中JNI（native方法）引用的对象

​	   **c.  如何高效地找到GC Roots并进行可达性分析？**		

​	   **d.  oopMap**

​		

​			

### 二、垃圾回收算法

#### 复制算法

从根集合节点开始，标记出所有存活的对象，将存活的对象复制到一块新的内存区域（内存连续【指正碰撞】），之后将原本那块内存全部回收掉。

优点：算法简单效率高

缺点：内存利用率低（一半内存空闲），在大量存活情况性能低（复制的对象多性能低），所以适用于新生代



**复制算法有stop the world，复制后对象的内存地址发生了变化，对象的引用和地址需要重新关联起来之后才能继续执行用户线程。**



#### 标记清除

标记清除分为：**标记和清除两个阶段**

通过根节点GC Root标记有从根节点开始的对象，没有

标记的对象就是未被引用的垃圾对象。然后在清除阶段清除所有未被标记的对象

##### 适用场景

存活对象觉多的情况效率高

适用于老年代

**缺点**

**存在内存碎片问题，当内存碎片多了之后，无法存放新的大对象而提前触发垃圾回收**



#### 标记整理

标记清除的基础上，增加了压缩过程。在进行标记清除后，对内存空间进行压缩，解决内存不连续（内存碎片）的问题。注意标记压缩算法也会产生“stop the world”，因为压缩过程中一些对象的内存地址发生了改变，java程序只能等压缩完后才能继续。



#### 分代收集（复合算法）

一种复合算法，不是全新的算法，是将三种基础算法取长补短整合起来。



#### 增量收集算法（复合算法）

**【基本思想】**

如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程**交替执行**。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。

总的来说，增量收集算法的基础仍是传统的**标记-清除-整理和复制算法**。增量收集算法通过对线程间冲突的妥善处理，**允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作**。

> 好比你攒了一个月的脏衣服和一周的脏衣服，虽然穿新都很爽，但是洗衣火葬场

**【缺点】**：频繁的切换用户线程和GC线程，造成系统吞吐量的下降

垃圾回收器的衡量指标：

- 低延迟

- 吞吐量

  

#### 分区算法（复合算法）





### 三、垃圾收集器

7种垃圾收集器，Serial、Serial Old、ParNew、Parallel Scavenge、Parallel Old、Cms、G1

Serial、ParNew、Parallel Scavenge 作用于新生代的垃圾收集器

Serial Old、Parallel Old、Cms  作用于老年代的垃圾收集器

G1 既可以进行新生代垃圾回收也可以进行老年代垃圾回收

**图中红X部分，JDK1.8之后不再支持**

![](image\GC_zrea.png)

#### 垃圾收集器分类

https://blog.csdn.net/u012882134/article/details/78422258

1. 串行垃圾回收器

   单线程的垃圾收集器， 垃圾收集线程工作时必须暂停其它所有用户线程Stop-the-World

   Serial

   Serial Old

2. 并行垃圾回收器

   垃圾回收线程并行的进行垃圾回收，垃圾回收线程工作时必须暂停所有用户线程造成Stop-the-World

   ParNew

   Parallel Scavenge

   Parallel  Old

3. 并发垃圾回收器

   CMS

4. G1垃圾回收器

   G1

#### Serial

串行垃圾收集器，使用【复制算法】，单线程的垃圾收集器， **垃圾收集线程工作时必须暂停其它所有用户线程Stop-the-World**，适用于单一应用和单核服务器或者内存空间很小100m

![](image\serial.png)

#### Serial Old

串行老年代垃圾回收器与Serial垃圾收集器一样，不同的是它作用于老年代，使用【标记-整理】算法。

当CMS作为老年代的垃圾收集器，故障时**serial old可以作为CMS备选**



#### ParNew

并行新生代垃圾回收器，使用**复制算法**，多个垃圾回收线程并行进行垃圾回收，比较Serial性能有所提高。

垃圾回收时需要暂停所有用户线程（stop the world）,它只能与**CMS**配合使用

![image-20210125163956960](image\parnew.png)



#### Parallel Scavenge

**并行**新生代垃圾回收器，使用**复制算法**，俗称**吞吐量优先收集器**，可控制的吞吐量。

**吞吐量 = 运行用户代码时间/(运行用户代码时间+垃圾回收时间)，高吞吐量意味着高效利用CPU**，

适用于后台计算而不需要太多交互的任务。

**自适应调节策略**也是Parallel Scavenge与ParNew的一个重要区别，虚拟机根据当前系统运行情况动态调节参数以提供最合适的停顿时间和最大吞吐量（-XX:MaxGCPauseMillis）

##### jvm参数

`-XX:+UseParallelGC` -`XX:+UseParallelOldGC`  启用Parallel Scavenge垃圾收集器，这两个参数可以互相激活



**它与ParNew的区别就是能够控制吞吐量**



#### Parallel Old

Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“**标记-整理**”算法



#### CMS

并发标记清除垃圾收集器Concurrent Mark Sweep，作用于老年代， 基于**标记-清除**算法，垃圾回收线程和用户线程可同时工作

-XX:+UseConcMarkSweepGC

![image-20210125172700796](image\CMS.png)

##### 4步过程

1. 初始标记

   

2. 并发标记

3. 重新标记

4. 并发清除

```
[GC [1 CMS-initial-mark: 13991K(20288K)] 14103K(22400K), 0.0023781 secs] 
[GC [DefNew: 2112K->64K(2112K), 0.0837052 secs] 16103K->15476K(22400K), 0.0838519 secs] 
... 
[GC [DefNew: 2077K->63K(2112K), 0.0126205 secs] 17552K->15855K(22400K), 0.0127482 secs] 
[CMS-concurrent-mark: 0.267/0.374 secs] 
[GC [DefNew: 2111K->64K(2112K), 0.0190851 secs] 17903K->16154K(22400K), 0.0191903 secs] 
[CMS-concurrent-preclean: 0.044/0.064 secs] 
[GC [1 CMS-remark: 16090K(20288K)] 17242K(22400K), 0.0210460 secs] 
[GC [DefNew: 2112K->63K(2112K), 0.0716116 secs] 18177K->17382K(22400K), 0.0718204 secs] 
[GC [DefNew: 2111K->63K(2112K), 0.0830392 secs] 19363K->18757K(22400K), 0.0832943 secs] 
... 
[GC [DefNew: 2111K->0K(2112K), 0.0035190 secs] 17527K->15479K(22400K), 0.0036052 secs] 
[CMS-concurrent-sweep: 0.291/0.662 secs] [GC [DefNew: 2048K->0K(2112K), 0.0013347 secs] 17527K->15479K(27912K), 0.0014231 secs] [CMS-concurrent-reset: 0.016/0.016 secs] [GC [DefNew: 2048K->1K(2112K), 0.0013936 secs] 17527K->15479K(27912K), 0.0014814 secs ]
```

##### 优点

并发收集，回收速度快、低停顿（stop the world时间短）

##### 缺点

**1、CPU资源敏感**

用户线程、GC线程并行执行，他们之间会竞争CPU资源，尤其是当CPU数量少时竞争更加激烈GC效率受到严重影响，所以CMS适用于CPU数量多的情况



**2、空间碎片**

​	由于使用标记清除算法，空间碎片多，给对象分配带来麻烦，堆内存中找不到足够大的连续内存空间来分配对象



**3、无法回收浮动垃圾**

​	**并发清理**阶段，用户线程与垃圾回收线程并行执行，这个过程中用户线程产生新的垃圾对象（这就是浮动垃圾），由于标记已经结束这部分新产生的垃圾没有被标记，所以当次垃圾回收不会回收掉这部分

​	

#### G1

https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection

G1不同于传统的垃圾收集器，使用了全新的垃圾回收算法，区块化垃圾回收

###### 特点

适用于大内存多处理器的服务器，高吞吐量和低停顿的优点



##### 浮动垃圾

#### 低停顿







#### ZGC
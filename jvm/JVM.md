## JVM整体结构

jvm整体结构包含：

1、类加载子系统

2、运行时数据区

3、执行引擎

![image/jvm.jpg](image\jvm.jpg)



## 1、类加载子系统

### 类加载器

​	类加载器的类型
​		BootStrap ClassLoader		启动类加载器
​		Extension ClassLoader		扩展类加载器
​		Application ClassLoader	应用程序类加载器
​		Self ClassLoader		  自定义类加载器

	虽然类加载器只用于实现类加载动作，但在Java程序中起到的作用不止于此。对任意一个类都需要类加载器和类本身一起确定其在Java虚拟机中的唯一性，
		也就是说即便两个类来自同一个class文件，只要加载他们的类加载器不同，这两个类就不“相等”，相等包括equals(),isInstance(),instanceof
	
	类加载器不是继承关系而是组合关系

### 双亲委派机制


		双亲委派机制规定除了顶层类加载器外，其它加载器都有其父类加载器，这里的父子关系不是继承关系而是组合关系实现
		
		工作过程
			1、类加载器接收到类加载请求后，将其委托给自己的父类加载器去处理
			2、所有的类加载器都会将请求委托给父类加载器，所以最终都会委托给顶层的启动类加载器去加载
			3、只有当父类加载器反馈无法加载请求时，子类加载器尝试自己加载该类

​		

### 类加载机制

#### 静态绑定、动态绑定

#### 类加载过程


		加载、验证、准备、解析、初始化
		加载
			1、通过一个类全名获取编译后的二进制字节流
			2、将字节流所代表的静态数据结构转化为方法区中的运行时数据结构
			3、在Java堆中生成这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口（反射就是调用这个对象实现）			
		验证
			验证的目的确保Class文件中的字节流所包含的信息符合当前虚拟机的要求，不会危害虚拟机安全。验证的数据大致包括，
			文件格式验证、字节码验证、元数据验证、符号引用验证
		准备
			为类变量（static）分配内存并赋初值，这些类存空间分配在方法区中。
			static final修饰的常量必须显示的赋值，不然编译不通过，常量在编译器就将其结果方在了调用它的类的常量池中。
		解析
			解析阶段是虚拟机将符号引用转化为直接引用的过程。
		初始化
			初始化阶段为类变量赋值和初始化其它资源，简单说就是执行构造方法的过程。

#### 多态实现机制

##### 	静态分派、动态分派

​	

## 2、运行时数据区

### 堆

![heap](image\heap.png)

### 虚拟机栈

局部变量表：保存局部变量

操作数据栈：帮助计算

返回值



### 方法区

### 本地方法栈

### 程序技术器

用来记录下一条要执行的指令地址。

没有任何OutOfMemoryError情况的区域。



## 3、执行引擎

	Java虚拟机栈（先进后出）
		Java方法执行的内存模型，每个方法执行的时候都会创建一个栈贞，
		只有栈顶的栈贞是有效的，称为当前栈贞，代表当前正在执行的方法。
		栈贞中保存的数据：局部变量表、操作数栈、方法的返回地址、动态连接（符号引用）
			动态连接：每个栈贞都包含有一个指向运行时常量池（方法区中）该栈贞所属方法的符号引用，
			持有该符号引用是为了支持方法调用过程中的动态连接。
	
	Java堆
		线程共享，堆是虚拟机中最大的内存空间，几乎所有的对象实例和数组都在堆中分配内存，Heap是垃圾回收的主要区域。
		
	方法区
		线程共享，存储有已经被虚拟机加载的类信息、运行时常量池、常量、静态变量
		Java不要求常量一定在编译时产生，运行期间也能将新的常量放入常量池中（例如String 的 intern方法）
		
	本地方法栈
		与Java虚拟机栈一样，只是本地方法栈是为Native方法服务
		
	程序计数器
	记录线程当前执行的指令编码


​	



### 内存概念

https://blog.csdn.net/lckj686/article/details/84437600
	1、Java内存区域，运行时数据区，堆又细分新生代、老年代
	2、GC内存区
		新生代（eden、survival0、survival1）、老年代
	3、CPU内存模型
	4、JMM内存模型
	5、对象内存布局
	

### 垃圾回收机制

#### 垃圾对象的判断算法

​	引用计数
​		缺点：相互引用问题
​	根搜索算法

#### 垃圾回收算法

​	新生代：复制算法
​	老年代：标记整理算法、标记清除算法
​		标记清楚算法对需要回收的对象进行标记，这种算法效率不高并且会造成磁盘碎片



### 为什么jvm的年轻代要用复制算法？   

问题拆解 

1、什么是复制算法

复制算法的基本思想是将内存分为两块，每次使用一块当其中一块使用完时就将还活着的对象复制到另外一块内存上，然后再把另外一块清除。这样就使得每次只针对一块内存进行分配和回收，内存分配也不用考虑内存碎片的复杂情况，只要移动指针到堆顶按顺序分配，运行高效。

算法的代价：

只有一半的内存被使用，有一半内存没有存储内容

 2、年轻代的特点

a、Java虚拟机的年轻代有98%大量的对象在刚刚分配内存之后就会被回收，年轻代的内存区域较小，minor GC比较频繁，适用高效的回收算法。

b、HotSpot将年轻代分为eden区、两个幸存区survival0、survival1

结论：

年轻代的内存区域分为eden区



### 老年代为什么不使用复制算法？

1、老年代的对象大都存活时间长，使用复制算法每次要复制大量对象，效率低损耗性能。

2、老年代占用较大内存，复制算法会浪费内存。





#### tomcat为什么要自定义类加载器？

为了实现类加载的隔离。热加载

tomcat
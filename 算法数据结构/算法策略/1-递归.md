

## 递归的基本思想

### 拆解问题

​	把大规模的问题拆解成规模较小的同类型问题

​	规模较小的问题又拆解成规模更小的问题

​	规模小到一定层度可以直接得到问题的解

### 求解

​	最小规模问题的解得出较大规模问题的解

​	较大规模问题的解得出更大规模问题的解

​    最后得出原来问题的解



## 递归的使用套路

1. **明确函数的功能**

   先弄清楚这个函数干嘛用的，能完成什么功能？再写代码

2. **明确原问题与子问题的关系**

   寻找f(n) 与 f(n-1)的关系

3. **明确递归边界条件**

   递归结束条件（死循环）



## 递归转非递归

### **缺点**

1、递归调用的过程中，每一次调用都会开辟新的栈贞空间，存放方法对应的局部变量、方法出口等数据

若递归的深度较大，会消耗较大的栈贞空间，甚至导致栈溢出

2、递归调用包含大量的重复计算，时间复杂度高

**这时可以将递归转化为非递归（递归可以100%转化成非递归）**

### 转化方式

1、万能转化方式

**自己维护一个栈贞存储变量**，空间复杂度没有改善

2、有些时候可以**重复使用一组变量来保存每个栈贞的内容**

空间复杂度重O(n)转化成O(1)

这种方式往往是变量间存在一定的规律 可以 转化的情况



## 尾递归

编译器对栈空间进行优化，不另外开辟占空间，提升递归效率

## 练习

### 斐波拉契数列

如果使用递归，存在很多重复计算时间复杂度O(2^n)

### 爬楼梯

楼梯有n阶台阶，上楼可以- 步上1阶，也可以一步上2阶，走完n阶台阶共有多少种不同的走法

```java
/**
     * 递归
     * 时间复杂度O(2^n)，效率非常低
     * @param n
     * @return
     */
public static int climbStairs(int n) {
    if(n <= 2) {
        return n;
    }
    return climbStairs(n-1) + climbStairs(n-2);
}

/**
* 优化
*/
public static int climbStairs2(int n) {
    int first = 1;
    int second = 1;
    for (int i = 2; i <= n; i++) {
        second = first + second;
        first = second - first;
    }
    return second;
}
```

### 汉诺塔
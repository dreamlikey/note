指令重排序

#### 回顾

并发编程的三大问题：可见性、原子性、有序性

CPU缓存不能及时刷新到内存带来可见性问题（多CPU）

线程切换带来原子性问题（同一个CPU）

编译器为了优化性能而改变程序中语句的先后顺序导致有序性问题

**“编译器为了优化性能而改变程序中语句的先后顺序”是重排序的一种**

##### 特别说明

有些观点将 **处理器缓存不能及时更新到内存**的现象视为重排序的一种，称为**内存系统的重排序**，因为这种内存可见性问题造成的结果就好像内存指令发生了重排序。但这种现象并不是真正的重排序而是**内存可见性问题**，同时为了避免与可见性问题混淆这里将它定义为**伪重排序**。

#### 重排序概念

##### 真重排序

​	**在执行程序时为了提高性能，编译器和处理器(CPU)对指令做的重新排序**

从java源码到最终实际执行的指令序列，会分别经历下面二种重排序：

源代码--》编译器优化的重排序--》指令级并行的重排序--》最终指令

1. 编译器优化重排序

   在不改变单线程程序语意的情况下，编译器可以重新安排语句的执行顺序

2. 指令级并行重排序

   处理器将多条指令重叠执行。如果不存在数据依赖，处理器可以改变程序指令的执行顺序。

   

##### 伪重排序

可见性问题导致伪重排序，不是真正的重排序，**CPU缓存不能及时刷新，看起来指令被重排序了**

***特殊说明：***

有的观点把**处理器缓存不能及时更新到内存**的现象也视为重排序的一种，命名为“**内存系统的重排序”**



#### 重排序规则

##### 重排序准守数据依赖性

如果两个操作访问的同一个变量，且其中一个是写操作，此时这两个操作之间存在数据依赖性。

存在数据依赖性的三种情况：

① 写后读：a = 1;b = a; 写一个变量之后，再读这个位置。
② 写后写：a = 1;a = 2; 写一个变量之后，再写这个变量。
③ 读后写：a = b;b = 1;读一个变量之后，再写这个变量。

​	**存在数据依赖性的两个操作不可以重排序，数据依赖性只针对单个处理器中执行的程序指令和单个线程中执行的操作**

同一个线程中执行a=1;b=1; 不存在数据依赖性，可能重排序。

同一个线程中执行a=1;b=a; 存在数据依赖性，不可以重排序。



##### 重排序遵守as-if-serial 语义

as-if-serial语义：不管怎么重排序，单线程程序的执行结果不能改变。

A和B重排序之后，程序的执行结果不会改变，所以允许A、B重排序。A和C重排序之后，程序的执行结果会改变，所以不允许A、C重排序。

> 遵守数据依赖性和as-if-serial 语义实质上是一回事。为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。

#### 重排序带来的问题

重排序可以提高程序执行的性能，但程序执行顺序的改变，可能会导致多线程程序的**有序性问题**

举例

```java

public class PossibleReordering {
static int x = 0, y = 0;
static int a = 0, b = 0;

public static void main(String[] args) throws InterruptedException {
    Thread one = new Thread(new Runnable() {
        public void run() {
            a = 1; // A1
			x = b; // A2
        }
    });
    
    Thread other = new Thread(new Runnable() {
        public void run() {
            b = 1; // B1
			y = a; // B2
        }
    });
    one.start();other.start();
    one.join();other.join();
    System.out.println(“(” + x + “,” + y + “)”);
}
```

如上代码，输出结果可能是(1,0) (0,1) (1,1)，因为线程one可以在线程two开始之前就执行完了，也有可能反之，甚至有可能二者的指令是同时或交替执行的，**实际上还有可能是(0,0)**。



![重排序](image\重排序.jpg)



造成(0,0)这种结果的原因有两种：

1、**指令重排序**

​	实际运行时，A1/B1、A2/B2的执行顺序发生了变化A2/B2在A1/B1之前

2、**可见性问题**，处理器缓存不能及时刷新到内存，A2、B2读取的内存值是还未刷新到内存的值

第一步执行A1/B1将a=1写到缓冲区，此时写缓冲区还在等待其他写操作，不执行A3，所以内存中的a=0;

第二步执行A2/B2，处理器读取内存中的a，得到a=0;

**虽然处理器 A 执行内存操作的顺序为：A1->A2，但实际结果却是a=0，看上去好像是处理器将内存操作顺序重排为A2->A1，但实际情况是处理器缓冲区没有及时将a=1刷新到内存的原因。**



#### JMM如何解决重排序问题

1. 对于编译器，JMM规则会禁止某些类型的编译器（不是所有编译器）进行重排序。

2. 对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成程序指令时，插入特定类型的内存屏障指令，来禁止特定类型的处理器重排序。

3. JMM根据代码中的关键字（synchronized、volatitle、final）或JUC包下的具体类来插入内存屏障。

   

JMM把内存屏障指令分为四类

![JMM内存屏障指令](image\JMM内存屏障指令.jpg)

**Store：数据对其它处理器可见（刷新到内存中）**

**Load：处理器缓存中的数据失效，重新从内存中读取数据**



#### 总结

1. 重排序：在程序执行时为了提升性能，编译器和处理器对程序指令进行的重新排序
2. 编译器重排程序中语句的先后顺序 属于 重排序的一种
3. 从java源码到指令最终执行要经历二种重排序：编译器优化的重排序、指令级并行的重排序
4. 存在依赖性的两个操作，不能重排序
5. as-if-serial语义要求：不管如何重排序，程序执行结果不能改变
6. JMM编译时在特定位置插入内存屏障指令，禁止特定类型的指令重排序



推荐文章链接

<https://www.jianshu.com/p/c6f190018db1>

<https://tech.meituan.com/2014/09/23/java-memory-reordering.html>
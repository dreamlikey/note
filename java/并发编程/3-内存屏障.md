内存屏障：memory barrier

#### 内存屏障概念

内存屏障是一种计算机指令，目的是保证数据的可见性和防止指令之间的重排序。

因为多核CPU多线程执行程序会有可见性问题、有序性问题，内存屏障可以防止这两种并发问题；指令重排序导致有序性问题，CPU缓存不能及时更新到主内存导致可见性问题。



#### 内存屏障作用

内存屏障的作用有两个保证数据可见性、防止指令重排序

##### 保证可见性

CPU修改了内存中的数据不会及时更新到内存而是先保存在CPU写缓冲区（store buffer），这时其它CPU从内存中读取到的数据就不是最新的，也就是说这时CPU修改的数据对其它CPU是不可见的，导致了可见性问题。其它CPU为了读取到最新的数据，**需要执行内存屏障指令，将CPU写缓冲区store buffer中的数据 写到内存中**。

##### 防止重排序

编译器或处理器执行程序指令时为了优化性能，会对指令进行重新排序执行，编译器、处理器进行指令重排序时都要准守as-if-serial原则，即不管怎么重排序最终结果不能改变。多CPU多线程运行情况下指令重排序可能会出现有序性问题，这是需要内存屏障来保证指令的执行顺序。



#### 内存屏障类型

##### 处理器的重排序分类

不同的处理器对重排序规定不同：

![处理器允许的重排序类型](image\处理器允许的重排序类型.jpg)

N表示不允许两个操作重排序，Y表示允许两个操作重排序

一般的处理器不允许数据依赖的操作重排序，允许store-load操作重排序。



##### JMM内存屏障指令

不同类型的处理器对重排序的支持不同，Java为了保证程序的可见性、有序性，**编译器在程序指令之间插入内存屏障指令来禁止特定类型的处理器进行指令重排序**，JMM把内存屏障指令分为以下四类：

| 屏障类型            | 指令示例                 | 说明                                                         |
| ------------------- | ------------------------ | ------------------------------------------------------------ |
| LoadLoad Barriers   | Load1;LoadLoad;Load2     | 该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作 |
| StoreStore Barriers | Store1;StoreStore;Store2 | 该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作 |
| LoadStore Barriers  | Load1;LoadStore;Store2   | 确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作 |
| StoreLoad Barriers  | Store1;StoreLoad;Load2   | 该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令 |

StoreLoad Barriers是全能屏障，它同时具有其它三种内存屏障的效果，执行这种屏障指令的开销也很昂贵，因为当前处理器需要把缓冲区的数据都刷新到内存中（buffer fully flush）

##### store barrier

对应sfence指令

##### load barrier

对应lfence指令

##### full barrier

对应mfence指令

#### 总结

什么是内存屏障

计算机指令，保证数据可见性、防止指令重排序。

不同类型的处理器对内存屏障的支持不同，JMM为了保证java程序的可见性、有序性编译器在生成指令序列的适当位置插入内存屏障指令，以禁止某些特定类型的处理器进行指令重排序。


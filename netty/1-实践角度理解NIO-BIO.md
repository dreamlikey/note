### BIO

#### 阻塞IO

**BIO会产生两次阻塞**

第一次：服务器等待连接，如果没有客户端连接服务端会一直等待下去

第二次：客户端连接后，服务端等待客户端发送数据，如果客户端没有发送数据服务端会一直等待下去



#### BIO处理并发

每个客户端连接开启一个线程处理



#### 多线程BIO服务器的弊端

如果大理请求连接到服务器，每个连接创建一个线程，会对服务器造成很大的压力



### NIO

#### 非阻塞IO

NIO解决的根本问题是BIO的两个阻塞



#### 模拟解决阻塞

缓存连接到list集合中，轮询连接数据是否准备好，数据准好立即做处理。这样在等待数据时不会阻塞其它连接

##### 弊端

大量连接的情况下这种轮询的方式效率很低

另外，比如1000万连接中只有100万在发送数据，剩下的900万不发送任何消息，这些连接依然都会轮询，这显然是不合适的



#### NIO解决阻塞方式

真正的NIO不会在Java代码层面去轮询连接，而是将轮询这个步骤交给操作系统去进行，将轮询的那部分代码改为操作系统级别的调用(windows select函数，linux epoll)，在操作系统上调用select函数，**主动去感知有数据的socket**



##### Java层面的轮询与select的区别

Java程序其本质在轮询每个socket的时候都要去调用系统函数，轮询一次调用一次造成不必要的上下文切换开销

select将所有请求从 用户态空间 全量复制一份到 内核态空间，在内核态空间来判断数据是否准备好，避免频繁的上下文切换，所以select比程序轮询效率高的多。



### select/epoll

#### select

##### 底层逻辑

##### 缺点

再次遍历



#### epoll





参考文章：

<https://mp.weixin.qq.com/s/lBg2YAunczH1DUjBvIurhQ>

https://mp.weixin.qq.com/s/7hcRgO70zYrplq_4Mk9uaA